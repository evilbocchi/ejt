#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const ts = require("typescript");

const ROOT = path.resolve(__dirname, "..");
const GENERATED_PATH = path.join(ROOT, "difficulties", "generated.ts");
const INDEX_PATH = path.join(ROOT, "src", "index.ts");
const HANDWRITTEN_PATH = path.join(ROOT, "difficulties", "handwritten-difficulties.json");

const START_MARKER = "\t// <AUTO-GENERATED-STATIC-DIFFICULTIES>";
const END_MARKER = "\t// </AUTO-GENERATED-STATIC-DIFFICULTIES>";

function readGeneratedEntries() {
	const source = fs.readFileSync(GENERATED_PATH, "utf8");
	const sourceFile = ts.createSourceFile("generated.ts", source, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);

	const entries = new Map();
	const keys = [];

	const getPropertyName = (name) => {
		if (ts.isIdentifier(name) || ts.isStringLiteral(name) || ts.isNumericLiteral(name)) {
			return name.text;
		}
		return undefined;
	};

	let found = false;

	const visit = (node) => {
		if (ts.isVariableStatement(node)) {
			for (const declaration of node.declarationList.declarations) {
				if (ts.isIdentifier(declaration.name) && declaration.name.text === "GENERATED_DIFFICULTIES") {
					const initializer = declaration.initializer;
					if (initializer && ts.isObjectLiteralExpression(initializer)) {
						found = true;
						for (const property of initializer.properties) {
							if (!ts.isPropertyAssignment(property)) {
								continue;
							}

							const keyName = getPropertyName(property.name);
							if (!keyName) {
								continue;
							}

							const value = property.initializer;
							if (!ts.isObjectLiteralExpression(value)) {
								continue;
							}

							const entry = {};
							for (const entryProperty of value.properties) {
								if (!ts.isPropertyAssignment(entryProperty)) {
									continue;
								}

								const entryKey = getPropertyName(entryProperty.name);
								if (!entryKey) {
									continue;
								}

								entry[entryKey] = entryProperty.initializer.getText(sourceFile).trim();
							}

							entries.set(keyName, entry);
							keys.push(keyName);
						}
					}
				}
			}
		}

		ts.forEachChild(node, visit);
	};

	visit(sourceFile);

	if (!found || keys.length === 0) {
		throw new Error("No generated difficulties found in difficulties/generated.ts");
	}

	return { entries, keys };
}

function readHandwrittenOverrides() {
	if (!fs.existsSync(HANDWRITTEN_PATH)) {
		return [];
	}

	const raw = fs.readFileSync(HANDWRITTEN_PATH, "utf8");
	const data = JSON.parse(raw);
	if (!Array.isArray(data)) {
		throw new Error("handwritten-difficulties.json must contain an array");
	}

	return data;
}

function formatNumber(value) {
	if (Number.isNaN(value)) {
		return "Number.NaN";
	}

	if (value === Number.POSITIVE_INFINITY) {
		return "math.huge";
	}

	if (value === Number.NEGATIVE_INFINITY) {
		return "-math.huge";
	}

	return Number(value).toString();
}

function parseStringLiteral(text, fallback) {
	if (typeof text !== "string") {
		return fallback;
	}

	try {
		return JSON.parse(text);
	} catch (error) {
		return fallback;
	}
}

function buildStaticProperty(key, override, entry) {
	const lines = [];
	const baseIndent = "\t";
	const chainIndent = "\t\t";
	const hasGenerated = Boolean(entry);
	const effectiveOverride = override ?? {};
	const overrideHas = (prop) => override && Object.prototype.hasOwnProperty.call(override, prop);
	const entryHas = (prop) => entry && Object.prototype.hasOwnProperty.call(entry, prop);

	const idText = hasGenerated && entryHas("id") ? parseStringLiteral(entry.id, key) : key;
	const chain = [];

	const nameExpr = overrideHas("name")
		? JSON.stringify(effectiveOverride.name ?? "")
		: entryHas("name")
		? entry.name
		: JSON.stringify(key);
	const nameDoc = parseStringLiteral(nameExpr, nameExpr ?? "");
	chain.push(`.setName(${nameExpr})`);

	const descriptionExpr = overrideHas("description")
		? JSON.stringify(effectiveOverride.description ?? "")
		: entryHas("description")
		? entry.description
		: undefined;
	const descriptionDoc =
		descriptionExpr !== undefined ? parseStringLiteral(descriptionExpr, descriptionExpr) : undefined;
	if (descriptionExpr !== undefined) {
		chain.push(`.setDescription(${descriptionExpr})`);
	}

	const visualRatingExpr = overrideHas("visualRating")
		? JSON.stringify(effectiveOverride.visualRating ?? "")
		: entryHas("visualRating")
		? entry.visualRating
		: undefined;
	const visualRatingDoc =
		visualRatingExpr !== undefined ? parseStringLiteral(visualRatingExpr, visualRatingExpr) : undefined;
	if (visualRatingExpr !== undefined) {
		chain.push(`.setVisualRating(${visualRatingExpr})`);
	}

	const layoutRatingExpr = overrideHas("layoutRating")
		? formatNumber(effectiveOverride.layoutRating)
		: entryHas("layoutRating")
		? entry.layoutRating
		: undefined;
	const layoutRatingDoc = layoutRatingExpr;
	if (layoutRatingExpr !== undefined) {
		chain.push(`.setLayoutRating(${layoutRatingExpr})`);
	}

	const classExpr = overrideHas("class")
		? formatNumber(effectiveOverride.class)
		: entryHas("class")
		? entry.class
		: undefined;
	const classDoc = classExpr;
	if (classExpr !== undefined) {
		chain.push(`.setClass(${classExpr})`);
	}

	let colorDoc;
	if (effectiveOverride.color && typeof effectiveOverride.color === "object") {
		const { r, g, b } = effectiveOverride.color;
		colorDoc = { r, g, b };
		chain.push(`.setColor(Color3.fromRGB(${r}, ${g}, ${b}))`);
	} else if (entryHas("colorR") && entryHas("colorG") && entryHas("colorB")) {
		const parseColorComponent = (value) => {
			const numeric = Number(value);
			return Number.isFinite(numeric) ? numeric : value;
		};

		colorDoc = {
			r: parseColorComponent(entry.colorR),
			g: parseColorComponent(entry.colorG),
			b: parseColorComponent(entry.colorB),
		};
		chain.push(`.setColor(Color3.fromRGB(${entry.colorR}, ${entry.colorG}, ${entry.colorB}))`);
	}

	let imageDoc;
	if (overrideHas("image")) {
		const imageValue = effectiveOverride.image ?? "";
		imageDoc = imageValue;
		chain.push(`.setImage(${JSON.stringify(imageValue)})`);
	} else if (entryHas("image") && entry.image !== '""') {
		imageDoc = parseStringLiteral(entry.image, "");
		chain.push(`.setImage(${entry.image})`);
	}

	const docLines = [];
	const addDocLine = (content = "") => {
		if (content.length === 0) {
			docLines.push(`${baseIndent} *`);
		} else {
			docLines.push(`${baseIndent} * ${content}`);
		}
	};

	const formatOptional = (value) => {
		if (value === undefined || value === null) {
			return undefined;
		}

		if (typeof value === "string") {
			const trimmed = value.trim();
			return trimmed.length === 0 ? undefined : trimmed;
		}

		return value.toString();
	};

	docLines.push(`${baseIndent}/**`);
	addDocLine(`### ${formatOptional(nameDoc) ?? "(not provided)"} (${idText})`);

	const visualRatingDisplay = formatOptional(visualRatingDoc);
	const layoutRatingDisplay = formatOptional(layoutRatingDoc);
	if (visualRatingDisplay !== undefined) {
		addDocLine(`- Rating: ${visualRatingDisplay} (Layout: ${layoutRatingDisplay})`);
	}

	const classDisplay = formatOptional(classDoc);
	if (classDisplay !== undefined) {
		addDocLine(`- Class: ${classDisplay}`);
	}

	if (colorDoc) {
		const componentToString = (component) =>
			typeof component === "number" ? component.toString() : `${component}`;
		addDocLine(
			`- Color: rgb(${componentToString(colorDoc.r)}, ${componentToString(colorDoc.g)}, ${componentToString(
				colorDoc.b,
			)})`,
		);
	}

	if (imageDoc !== undefined) {
		const imageDisplay = formatOptional(imageDoc) ?? "(not provided)";
		addDocLine(`- Image: ${imageDisplay}`);
	}

	const descriptionDisplay = typeof descriptionDoc === "string" ? descriptionDoc : undefined;
	if (descriptionDisplay && descriptionDisplay.trim().length > 0) {
		addDocLine();
		const descriptionLines = descriptionDisplay.split(/\r?\n/);
		for (const line of descriptionLines) {
			if (line.length === 0) {
				addDocLine();
			} else {
				addDocLine(line);
			}
		}
	}

	docLines.push(`${baseIndent} */`);

	lines.push(...docLines);
	lines.push(`${baseIndent}static readonly ${key} = new Difficulty(${JSON.stringify(idText)})`);

	if (chain.length === 0) {
		lines[lines.length - 1] += ";";
	} else {
		for (let i = 0; i < chain.length; i += 1) {
			const suffix = i === chain.length - 1 ? ";" : "";
			lines.push(`${chainIndent}${chain[i]}${suffix}`);
		}
	}

	return lines.join("\n");
}

function createOverrideMap(overrides) {
	const map = new Map();
	for (const entry of overrides) {
		if (!entry || typeof entry.propertyName !== "string") {
			continue;
		}

		const trimmedName = entry.propertyName.trim();
		if (trimmedName.length === 0) {
			continue;
		}

		const normalized = trimmedName.toLowerCase();
		if (!map.has(normalized)) {
			map.set(normalized, {
				propertyName: trimmedName,
				override: entry,
			});
		}
	}

	return map;
}

function buildStaticBlock(generatedKeys, overrides, generatedEntries) {
	const overrideMap = createOverrideMap(overrides);
	const properties = [];

	for (const key of generatedKeys) {
		const entry = generatedEntries.get(key);
		if (!entry) {
			throw new Error(`Missing generated difficulty entry for key: ${key}`);
		}

		const normalizedKey = key.toLowerCase();
		const overrideInfo = overrideMap.get(normalizedKey);
		const propertyName = overrideInfo ? overrideInfo.propertyName : key;
		const override = overrideInfo ? overrideInfo.override : undefined;

		properties.push(buildStaticProperty(propertyName, override, entry));

		if (overrideInfo) {
			overrideMap.delete(normalizedKey);
		}
	}

	for (const { propertyName, override } of overrideMap.values()) {
		properties.push(buildStaticProperty(propertyName, override, undefined));
	}

	return properties.join("\n\n");
}

function updateIndexFile(block) {
	const source = fs.readFileSync(INDEX_PATH, "utf8");
	const startIndex = source.indexOf(START_MARKER);
	const endIndex = source.indexOf(END_MARKER);

	if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
		throw new Error("Unable to locate auto-generated block markers in src/index.ts");
	}

	const before = source.slice(0, startIndex + START_MARKER.length);
	const after = source.slice(endIndex);
	const newline = before.endsWith("\r\n") || source.includes("\r\n") ? "\r\n" : "\n";
	const normalizedBlock = block.split("\n").join(newline);

	const updated = `${before}${newline}${normalizedBlock}${newline}${END_MARKER}${after.slice(END_MARKER.length)}`;
	fs.writeFileSync(INDEX_PATH, updated, "utf8");
}

function main() {
	const { entries: generatedEntries, keys: generatedKeys } = readGeneratedEntries();
	const overrides = readHandwrittenOverrides();
	const block = buildStaticBlock(generatedKeys, overrides, generatedEntries);
	updateIndexFile(block);
}

main();
