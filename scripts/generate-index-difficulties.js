#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const ts = require("typescript");

const ROOT = path.resolve(__dirname, "..");
const GENERATED_PATH = path.join(ROOT, "difficulties", "generated.ts");
const INDEX_PATH = path.join(ROOT, "src", "index.ts");
const HANDWRITTEN_PATH = path.join(ROOT, "difficulties", "handwritten-difficulties.json");

const START_MARKER = "\t// <AUTO-GENERATED-STATIC-DIFFICULTIES>";
const END_MARKER = "\t// </AUTO-GENERATED-STATIC-DIFFICULTIES>";

function readGeneratedEntries() {
  const source = fs.readFileSync(GENERATED_PATH, "utf8");
  const sourceFile = ts.createSourceFile("generated.ts", source, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);

  const entries = new Map();
  const keys = [];

  const getPropertyName = (name) => {
    if (ts.isIdentifier(name) || ts.isStringLiteral(name) || ts.isNumericLiteral(name)) {
      return name.text;
    }
    return undefined;
  };

  let found = false;

  const visit = (node) => {
    if (ts.isVariableStatement(node)) {
      for (const declaration of node.declarationList.declarations) {
        if (ts.isIdentifier(declaration.name) && declaration.name.text === "GENERATED_DIFFICULTIES") {
          const initializer = declaration.initializer;
          if (initializer && ts.isObjectLiteralExpression(initializer)) {
            found = true;
            for (const property of initializer.properties) {
              if (!ts.isPropertyAssignment(property)) {
                continue;
              }

              const keyName = getPropertyName(property.name);
              if (!keyName) {
                continue;
              }

              const value = property.initializer;
              if (!ts.isObjectLiteralExpression(value)) {
                continue;
              }

              const entry = {};
              for (const entryProperty of value.properties) {
                if (!ts.isPropertyAssignment(entryProperty)) {
                  continue;
                }

                const entryKey = getPropertyName(entryProperty.name);
                if (!entryKey) {
                  continue;
                }

                entry[entryKey] = entryProperty.initializer.getText(sourceFile).trim();
              }

              entries.set(keyName, entry);
              keys.push(keyName);
            }
          }
        }
      }
    }

    ts.forEachChild(node, visit);
  };

  visit(sourceFile);

  if (!found || keys.length === 0) {
    throw new Error("No generated difficulties found in difficulties/generated.ts");
  }

  return { entries, keys };
}

function readHandwrittenOverrides() {
  if (!fs.existsSync(HANDWRITTEN_PATH)) {
    return [];
  }

  const raw = fs.readFileSync(HANDWRITTEN_PATH, "utf8");
  const data = JSON.parse(raw);
  if (!Array.isArray(data)) {
    throw new Error("handwritten-difficulties.json must contain an array");
  }

  return data;
}

function formatNumber(value) {
  if (Number.isNaN(value)) {
    return "Number.NaN";
  }

  if (value === Number.POSITIVE_INFINITY) {
    return "math.huge";
  }

  if (value === Number.NEGATIVE_INFINITY) {
    return "-math.huge";
  }

  return Number(value).toString();
}

function parseStringLiteral(text, fallback) {
  if (typeof text !== "string") {
    return fallback;
  }

  try {
    return JSON.parse(text);
  } catch (error) {
    return fallback;
  }
}

function buildStaticProperty(key, override, entry) {
  const lines = [];
  const baseIndent = "\t";
  const chainIndent = "\t\t";
  const hasGenerated = Boolean(entry);
  const effectiveOverride = override ?? {};
  const overrideHas = (prop) => override && Object.prototype.hasOwnProperty.call(override, prop);
  const entryHas = (prop) => entry && Object.prototype.hasOwnProperty.call(entry, prop);

  const idText = hasGenerated && entryHas("id") ? parseStringLiteral(entry.id, key) : key;
  lines.push(`${baseIndent}static readonly ${key} = new Difficulty(${JSON.stringify(idText)})`);

  const chain = [];

  const nameExpr = overrideHas("name")
    ? JSON.stringify(effectiveOverride.name ?? "")
    : entryHas("name")
      ? entry.name
      : JSON.stringify(key);
  chain.push(`.setName(${nameExpr})`);

  const descriptionExpr = overrideHas("description")
    ? JSON.stringify(effectiveOverride.description ?? "")
    : entryHas("description")
      ? entry.description
      : undefined;
  if (descriptionExpr !== undefined) {
    chain.push(`.setDescription(${descriptionExpr})`);
  }

  const visualRatingExpr = overrideHas("visualRating")
    ? JSON.stringify(effectiveOverride.visualRating ?? "")
    : entryHas("visualRating")
      ? entry.visualRating
      : undefined;
  if (visualRatingExpr !== undefined) {
    chain.push(`.setVisualRating(${visualRatingExpr})`);
  }

  const layoutRatingExpr = overrideHas("layoutRating")
    ? formatNumber(effectiveOverride.layoutRating)
    : entryHas("layoutRating")
      ? entry.layoutRating
      : undefined;
  if (layoutRatingExpr !== undefined) {
    chain.push(`.setLayoutRating(${layoutRatingExpr})`);
  }

  const classExpr = overrideHas("class")
    ? formatNumber(effectiveOverride.class)
    : entryHas("class")
      ? entry.class
      : undefined;
  if (classExpr !== undefined) {
    chain.push(`.setClass(${classExpr})`);
  }

  if (effectiveOverride.color && typeof effectiveOverride.color === "object") {
    const { r, g, b } = effectiveOverride.color;
    chain.push(`.setColor(Color3.fromRGB(${r}, ${g}, ${b}))`);
  } else if (entryHas("colorR") && entryHas("colorG") && entryHas("colorB")) {
    chain.push(`.setColor(Color3.fromRGB(${entry.colorR}, ${entry.colorG}, ${entry.colorB}))`);
  }

  if (overrideHas("image")) {
    const imageValue = effectiveOverride.image ?? "";
    chain.push(`.setImage(${JSON.stringify(imageValue)})`);
  } else if (entryHas("image") && entry.image !== "\"\"") {
    chain.push(`.setImage(${entry.image})`);
  }

  if (chain.length === 0) {
    lines[lines.length - 1] += ";";
  } else {
    for (let i = 0; i < chain.length; i += 1) {
      const suffix = i === chain.length - 1 ? ";" : "";
      lines.push(`${chainIndent}${chain[i]}${suffix}`);
    }
  }

  return lines.join("\n");
}

function buildStaticBlock(keys, overrides, generatedEntries, generatedKeys) {
  const overrideMap = new Map();
  for (const entry of overrides) {
    if (!entry || typeof entry.propertyName !== "string") {
      continue;
    }

    if (!overrideMap.has(entry.propertyName)) {
      overrideMap.set(entry.propertyName, entry);
    }
  }

  const generatedSet = new Set(generatedKeys);
  const seen = new Set();
  const orderedKeys = [];

  for (const key of keys) {
    if (seen.has(key)) {
      continue;
    }

    seen.add(key);
    orderedKeys.push(key);
  }

  for (const [key] of overrideMap) {
    if (!generatedSet.has(key) && !seen.has(key)) {
      seen.add(key);
      orderedKeys.push(key);
    }
  }

  const properties = orderedKeys.map((key) => {
    const override = overrideMap.get(key);
    const entry = generatedEntries.get(key);
    return buildStaticProperty(key, override, entry);
  });

  return properties.join("\n\n");
}

function updateIndexFile(block) {
  const source = fs.readFileSync(INDEX_PATH, "utf8");
  const startIndex = source.indexOf(START_MARKER);
  const endIndex = source.indexOf(END_MARKER);

  if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
    throw new Error("Unable to locate auto-generated block markers in src/index.ts");
  }

  const before = source.slice(0, startIndex + START_MARKER.length);
  const after = source.slice(endIndex);
  const newline = before.endsWith("\r\n") || source.includes("\r\n") ? "\r\n" : "\n";
  const normalizedBlock = block.split("\n").join(newline);

  const updated = `${before}${newline}${normalizedBlock}${newline}${END_MARKER}${after.slice(END_MARKER.length)}`;
  fs.writeFileSync(INDEX_PATH, updated, "utf8");
}

function main() {
  const { entries: generatedEntries, keys: generatedKeys } = readGeneratedEntries();
  const overrides = readHandwrittenOverrides();

  const overrideNames = overrides
    .filter((entry) => entry && typeof entry.propertyName === "string")
    .map((entry) => entry.propertyName);

  const keys = [...generatedKeys, ...overrideNames];
  const block = buildStaticBlock(keys, overrides, generatedEntries, generatedKeys);
  updateIndexFile(block);
}

main();
