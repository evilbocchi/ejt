#!/usr/bin/env node

const fs = require("fs");
const path = require("path");

const ROOT = path.resolve(__dirname, "..");
const GENERATED_PATH = path.join(ROOT, "src", "generated.ts");
const INDEX_PATH = path.join(ROOT, "src", "index.ts");
const HANDWRITTEN_PATH = path.join(ROOT, "difficulties", "handwritten-difficulties.json");

const START_MARKER = "\t// <AUTO-GENERATED-STATIC-DIFFICULTIES>";
const END_MARKER = "\t// </AUTO-GENERATED-STATIC-DIFFICULTIES>";

function readGeneratedKeys() {
  const source = fs.readFileSync(GENERATED_PATH, "utf8");
  const regex = /^\s{2}([A-Za-z0-9_]+): \{$/gm;
  const keys = [];
  let match;
  while ((match = regex.exec(source)) !== null) {
    keys.push(match[1]);
  }

  if (keys.length === 0) {
    throw new Error("No generated difficulties found in src/generated.ts");
  }

  return keys;
}

function readHandwrittenOverrides() {
  if (!fs.existsSync(HANDWRITTEN_PATH)) {
    return [];
  }

  const raw = fs.readFileSync(HANDWRITTEN_PATH, "utf8");
  const data = JSON.parse(raw);
  if (!Array.isArray(data)) {
    throw new Error("handwritten-difficulties.json must contain an array");
  }

  return data;
}

function formatNumber(value) {
  if (Number.isNaN(value)) {
    return "Number.NaN";
  }

  if (value === Number.POSITIVE_INFINITY) {
    return "math.huge";
  }

  if (value === Number.NEGATIVE_INFINITY) {
    return "-math.huge";
  }

  return Number(value).toString();
}

function buildStaticProperty(key, override, hasGenerated) {
  const lines = [];
  const baseIndent = "\t";
  const chainIndent = "\t\t";
  const initializer = hasGenerated
    ? `Difficulty.fromGeneratedEntry(GENERATED_DIFFICULTIES.${key})`
    : `new Difficulty(${JSON.stringify(key)})`;

  lines.push(`${baseIndent}static readonly ${key} = ${initializer}`);

  const chain = [];
  const effectiveOverride = override ?? {};

  if (!hasGenerated) {
    const nameValue = effectiveOverride.name ?? key;
    chain.push(`.setName(${JSON.stringify(nameValue)})`);
  } else if (Object.prototype.hasOwnProperty.call(effectiveOverride, "name")) {
    chain.push(`.setName(${JSON.stringify(effectiveOverride.name ?? "")})`);
  }

  if (Object.prototype.hasOwnProperty.call(effectiveOverride, "description")) {
    chain.push(`.setDescription(${JSON.stringify(effectiveOverride.description ?? "")})`);
  }

  if (Object.prototype.hasOwnProperty.call(effectiveOverride, "visualRating")) {
    chain.push(`.setVisualRating(${JSON.stringify(effectiveOverride.visualRating ?? "")})`);
  }

  if (Object.prototype.hasOwnProperty.call(effectiveOverride, "layoutRating")) {
    chain.push(`.setLayoutRating(${formatNumber(effectiveOverride.layoutRating)})`);
  }

  if (Object.prototype.hasOwnProperty.call(effectiveOverride, "class")) {
    chain.push(`.setClass(${formatNumber(effectiveOverride.class)})`);
  }

  if (effectiveOverride.color && typeof effectiveOverride.color === "object") {
    const { r, g, b } = effectiveOverride.color;
    chain.push(`.setColor(Color3.fromRGB(${r}, ${g}, ${b}))`);
  }

  if (Object.prototype.hasOwnProperty.call(effectiveOverride, "image")) {
    const imageValue = effectiveOverride.image ?? "";
    chain.push(`.setImage(${JSON.stringify(imageValue)})`);
  }

  if (chain.length === 0) {
    lines[lines.length - 1] += ";";
  } else {
    for (let i = 0; i < chain.length; i += 1) {
      const suffix = i === chain.length - 1 ? ";" : "";
      lines.push(`${chainIndent}${chain[i]}${suffix}`);
    }
  }

  return lines.join("\n");
}

function buildStaticBlock(keys, overrides, generatedKeys) {
  const overrideMap = new Map();
  for (const entry of overrides) {
    if (!entry || typeof entry.propertyName !== "string") {
      continue;
    }

    if (!overrideMap.has(entry.propertyName)) {
      overrideMap.set(entry.propertyName, entry);
    }
  }

  const generatedSet = new Set(generatedKeys);
  const seen = new Set();
  const orderedKeys = [];

  for (const key of keys) {
    if (seen.has(key)) {
      continue;
    }

    seen.add(key);
    orderedKeys.push(key);
  }

  for (const [key] of overrideMap) {
    if (!generatedSet.has(key) && !seen.has(key)) {
      seen.add(key);
      orderedKeys.push(key);
    }
  }

  const properties = orderedKeys.map((key) => {
    const override = overrideMap.get(key);
    const hasGenerated = generatedSet.has(key);
    return buildStaticProperty(key, override, hasGenerated);
  });

  return properties.join("\n\n");
}

function updateIndexFile(block) {
  const source = fs.readFileSync(INDEX_PATH, "utf8");
  const startIndex = source.indexOf(START_MARKER);
  const endIndex = source.indexOf(END_MARKER);

  if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
    throw new Error("Unable to locate auto-generated block markers in src/index.ts");
  }

  const before = source.slice(0, startIndex + START_MARKER.length);
  const after = source.slice(endIndex);
  const newline = before.endsWith("\r\n") || source.includes("\r\n") ? "\r\n" : "\n";
  const normalizedBlock = block.split("\n").join(newline);

  const updated = `${before}${newline}${normalizedBlock}${newline}${END_MARKER}${after.slice(END_MARKER.length)}`;
  fs.writeFileSync(INDEX_PATH, updated, "utf8");
}

function main() {
  const generatedKeys = readGeneratedKeys();
  const overrides = readHandwrittenOverrides();

  const overrideNames = overrides
    .filter((entry) => entry && typeof entry.propertyName === "string")
    .map((entry) => entry.propertyName);

  const keys = [...generatedKeys, ...overrideNames];
  const block = buildStaticBlock(keys, overrides, generatedKeys);
  updateIndexFile(block);
}

main();
